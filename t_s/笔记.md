# typescript笔记

## 全局安装 ts



```shell
yarn global add typescript
```

## 开发时实时编译

### 在浏览器中

在项目文件夹下启动命令行, 输入指令



```shell
tsc --init
```

会生成一个 `tsconfig.json` 文件, 找到 `outDir` 属性



```json
"outDir": "./js"
```

vscode 上面菜单栏 点击 ==终端== 选择 ==运行任务== 选择 ==tsc: 监视 …== 就可以实时编译 ts 生成对应的 js 到上面指定的路径下, 通过在 html 文件中引入 js 并启动 live server 就可以实现实时查看 ts 代码的效果.



### 在命令行中

全局安装工具 ts-node .

每次运行 ts-node xxx.ts 即可(它替代了每次要运行 tsc xxx.ts && node xxx.js)

## ts 的优势

1. 更容易发现潜在问题
2. 更好的代码提示
3. 更清晰的代码语义

## 类型检查

ts 最基本的功能就是做类型检查

### 原始类型

原始类型包括==string==, ==number==, ==boolean==, ==symbol==, ==undefined==, ==null==, ==void==.

如果声明一个变量而没有初始化, 就有必要指定类型

如果声明的时候就初始化了就没必要指定类型了, 因为 ts 会根据初始化赋的值自己判断出类型

这个很简单不赘述了



### 引用类型



```typescript
// 对象
const teacher: {
  name: string,
  age: number
} = {
  name: 'xxx',
  age: 25
}

console.log(teacher)

// 数组
const numbers: number[] = [1, 2, 3]

console.log(numbers)

// 类
class Person {}

const mike: Person = new Person()

// 函数
const getTotal: () => number = () => {
  return 123
}

function add(num1: number, num2: number): number {
  return num1 + num2
}
```



## 类型注解和类型推断

类型注解: 开发者指定变量类型

类型推断: ts 自己分析变量类型

如果 ts 分析不出来就需要告诉他类型



## 函数相关的类型



除了js中的原始类型和引用类型外, 还有 ==never==, ==void==.



```typescript
function add(num1: number, num2: number): number {
  return num1 + num2
}

const result = add(1, 2)
console.log(result)


// void 代表没有返回值, 如果有返回值会报错
function sayHello(): void {
  console.log('hello')
}

sayHello()

// never 代表无法执行到最后的函数(提前抛出异常, 或者死循环)
function neverFun (): never {
  throw new Error('404')
  console.log('error')
}

neverFun()

// 参数是解构的形式
function getTotalValue({ num1, num2} : { num1: number, num2: number}): number {
  return num1 + num2
}

const res = getTotalValue({ num1: 3, num2: 4 })
console.log(res)
```

注意: 解构也要对应解构, 即使解构的参数只有一个也要写成解构的形式



## 数组和元组

### 数组

#### 类型别名

```typescript
// 类型别名
type User = {
  name: string,
  age: number
}
const objArr: User[] = [{
  name: 'genji',
  age: 28
}]
```

ts 对对象和类区分的不是太严格, 即使类型指定的是某个类, 但实际使用时传入的是对象而不是这个类的实例也是可以的.



```typescript
class Hero {
  name: string
  age: number
}

const heroArr: Hero[] = [{
  name: 'lucio',
  age: 30
}]
```

### 元组

元组是按照指定的类型的顺序进行类型检查, 比类型别名更加严格



```typescript
// 元组
const studentinfo: [string, number, string] = ['崔佛', 40, 'fly']
// 上面元组比这个类型别名严格, 这个只要每个元素都在类型范围中就可以
const studaentinfo1: (string | number)[] = ['崔佛', 40, 123]
```

|              | 类型别名 | 元组               |
| ------------ | -------- | ------------------ |
| 元素个数限制 | :x:      | :white_check_mark: |
| 元素类型顺序 | :x:      | :white_check_mark: |



## interface 接口

interface 与 类型别名的区别

interface 只能用于引用类型, 类型别名都适用



### 接口的基本使用

#### 几个重要的语法 (?: readonly [propName]: any)

- hobby?: string  // 可有可无
- readonly sex: string  // 只读, 无法 set 该属性
- [propName: string]: any  // 不确定的属性



```typescript
const person = {
  name: 'peter',
  age: 18,
  hobby: 'cooking',
  sex: 'man',
  say() {
    return 'ts'
  }
}
// js 写法
/* const getPersonName = person => {
  console.log(person.name)
} */
// ts 写法
/* const getPersonName = (person: { name: string }): void => {
  console.log(person.name)
}
getPersonName(person) */


// js 写法
/* const setPersonName = (person, name) => {
  person.name = name
} */
// ts 写法
/* const setPersonName = (person: { name: string }, name: string): void => {
  person.name = name
}
setPersonName(person, 'lucy')
getPersonName(person) */

//^ 更优雅的做法就是用 interface
interface Person {
  name: string
  age: number
  hobby?: string  // 可有可无
  readonly sex: string  // 只读, 无法 set 该属性
  [propName: string]: any  // 不确定的属性
  say(): string
}

const getPersonName = (person: Person): void => {
  console.log(person.name, person.hobby, person.sex)
}
const setPersonName = (person: Person, name: string, sex: string): void => {
  person.name = name
  // person.sex = sex  // 报错, 因为是只读属性
}
getPersonName(person)  // 这个不会报错, 对引用的地址没有那么严格, 但是接口声明的属性一定要有
getPersonName({ name: 'lily', age: 23, hobby: 'dancing', sex: 'woman', say() { return 'hello'} }) // 这个会报错, 对字面量会严格检查


```



### 类实现接口



```typescript
interface Person1 {
  name: string
  age?: number
  [propName: string]: any
  say (): string
}

// 类实现接口
class User implements Person1 {
  name = 'user1'
  say() {
    return 'i am a user'
  }
}
// 实例化
const user = new User()
console.log(user, user.say())

// 接口继承
interface Teacher extends Person1 {
  job: string
}

// 入参待传对象
const teacher1 = {
  name: 'sigma',
  say() {
    return 'i am a teacher'
  },
  job: 'teacher'
}

// 定义方法
const getinfo = (teacher: Teacher): void => {
  console.log(teacher, teacher.say())
}
// 调用方法
getinfo(teacher1)

// 函数接口
interface SayHi {
  (word: string): string
}

const sayhi: SayHi = (word: string) => {
  console.log(word)
  return word
}

sayhi('hi')
```

## 类的定义与继承

```typescript
class Person {
  name: string
  constructor(name: string) {
    this.name = name
  }
  getName() {
    return this.name
  }
}

const person = new Person('peter')
console.log(person.getName())

// 继承
class Teacher extends Person {
  age = 18
  getInfo() {
    return [this.name, this.age]
  }
}

const teacher = new Teacher('Mccree')
console.log(teacher.getInfo())

// 重写
class Teacher1 extends Person {
  familyName: string
  constructor(name: string, familyName: string) {
    super(name)
    this.familyName = familyName
  }
  // 重写了父类的 getName 方法
  getName() {
    return super.getName() + ' ' + this.familyName
  }
  showName(): void {
    console.log(this.getName())
  }
}

const teacher1 = new Teacher1('Jesse', 'Mccree')
teacher1.showName()
```

super的作用之一就是在重写覆盖掉父类的同名方法后, 可以通过 super 继续访问父类的这个同名方法.

## 类中的访问类型和构造器

### 访问类型



```typescript
// 访问类型: private, protected, public
// public 允许在类的内外被调用
// private 允许在类内被使用
// protected 允许在类内和继承的子类使用
class Person {
  public name: string
  private age: number = 40
  protected hobby: string = 'cooking'
  public showAge(): number {
    return this.age
  }
}

class Chef extends Person {
  public showHobby() {
    return this.hobby
  }
}
const person = new Person()
person.name = 'mccree'
// person.age = 40  // 这句代码会报错, 因为person.age 属性是私有属性类外不可调用

console.log(person.name, person.showAge())

const chef = new Chef()
console.log(chef.showHobby())
```



### 构造器



```typescript
class Person {
  // 传统写法
  /* public name: string
  constructor(name: string) {
    this.name = name
  } */
  // 优雅的写法
  constructor(public name: string) {}
}

class Chef extends Person {
  constructor(public name: string, public age: number) {
    super(name)  // 即使父类是空的, 也要调用 super()
  }
  public sayInfo() {
    return this.name + ', ' + this.age
  }
}

const person = new Person('genji')
console.log(person.name)
const chef = new Chef('roadhog', 30)
console.log(chef.sayInfo())
```

## 类的静态方法, getter, setter

```typescript
class Person {
  constructor(private _name: string) { }
  get name() {
    return this._name
  }
  set name(name: string) {
    this._name = name
  }
}

const person = new Person('genji')
console.log(person.name)
person.name = 'Ziegler'
console.log(person.name)


// 单例模式
class Demo {
  // 把 constructor 设定为私有属性就限制了 new 关键字的创建
  private constructor(private name: string) { }
  // static 是该属性是类上的属性, 不是实例上的, 只能由类调用, 再加上 private 就无法从类外访问到了
  private static instance: Demo
  static getInstance(name: string) {
    if (!this.instance) {
      this.instance = new Demo(name)
    }
    return this.instance
  }
  public showName() {
    return this.name
  }
}

const demo1 = Demo.getInstance('roadhog')
const demo2 = Demo.getInstance('Junkrat')

console.log(demo1.showName(), demo2.showName())
console.log(demo1 === demo2)
```

## 抽象类

```typescript
// 抽象类
// 抽象类就是各类的共同的行为
// 抽象类不一定都是抽象方法, 也可以有其他的具体的实现
// 抽象类只能被继承不能被实例化, 只能继承, 而且一个子类只能继承一个抽象类
// 子类继承了抽象类就要实现抽象类里面的所有方法, 不然这个子类也只能是抽象类
// 抽象方法不能是 private , 因为 private 是类外访问不到的.
abstract class Geom {
  // 抽象方法
  abstract getArea(): number
  // 非抽象
  getClassName() {
    return 'Gemo'
  }
}

class Circle extends Geom {
  getArea() {
    return 123
  }
}

// 接口(区分一下这两个)
// 抽象类里面可以有方法的实现，但是接口完全都是抽象的，不存在方法的实现；
// 子类只能继承一个抽象类，而接口可以被多个实现；
// 抽象方法可以是public，protected，但是接口只能是public，默认的；
// 抽象类可以有构造器，而接口不能有构造器；
interface Person {
  name: string
}

interface Teacher extends Person {
  age: number
}

interface Devloper extends Person {
  lang: string
}

const getTeacherInfo = (teacher: Teacher) => {
  return teacher.name + ', ' + teacher.age
}

const getDevloperInfo = (devloper: Devloper) => {
  return devloper.name + ', ' + devloper.lang
}

const teacher1 = {
  name: 'peter',
  age: 30
}

const devloper1 = {
  name: 'mike',
  lang: 'ts'
}

console.log(getDevloperInfo(devloper1))
console.log(getTeacherInfo(teacher1))
```

## 实战: 使用 ts 实现一个小爬虫功能

url: http://www.dell-lee.com/typescript/demo.html?secret=x3b174jsx



### 使用superAgent和类型定义文件获取页面内容

初始化项目



```shell
yarn
tsc --init
```

typescript 和 ts-node 都安装成开发时依赖



```shell
yarn add -D typescript ts-node
```

安装 superagent 



```shell
yarn add superagent
```

ts 引入 js 文件会报错, 因为 js 中没有类型声明, 他们之间需要一个 `.d.ts` 翻译文件才行, 根据报错提示需要安装一个 `@types/superagent` 的东西.



```shell
yarn add -D @types/superagent
```

```typescript
// ts -> .d.ts 翻译文件 -> js
import superagent from 'superagent';

class Crowler {
  private secret = 'x3b174jsx'
  private url = `http://www.dell-lee.com/typescript/demo.html?secret=${this.secret}`
  private rawHtml = ''
  async getRawHtml() {
    const result = await superagent.get(this.url)
    console.log(result.text)
    // this.rawHtml = result.text
  }
  constructor() {
    // console.log(this.url)
    this.getRawHtml()
  }
}

const crowler = new Crowler()
```

### 使用 cheerio 进行数据爬取

安装 cheerio (这是一个能像 jquery 那样获取页面元素的库)



```typescript
// ts -> .d.ts 翻译文件 -> js
import superagent from 'superagent'
import cheerio from 'cheerio'

interface CourseInfos {
  title: string
  count: number
}
interface finalResult {
  time: number
  data: CourseInfos[]
}

class Crowler {
  private secret = 'x3b174jsx'
  private url = `http://www.dell-lee.com/typescript/demo.html?secret=${this.secret}`
  async getRawHtml() {
    const result = await superagent.get(this.url)
    console.log(result.text)
    this.getCourseInfo(result.text)
  }
  getCourseInfo(html: string) {
    const $ = cheerio.load(html)
    // console.log($)
    const courseItems = $('.course-item')
    const courseInfos: CourseInfos[] = []
    const finalResult: finalResult = { time: new Date().getTime(), data: courseInfos }
    courseItems.map((index, ele) => {
      const descs = $(ele).find('.course-desc')
      const title = descs.eq(0).text()
      const count = parseInt(descs.eq(1).text().split('：')[1], 10)
      // console.log(title, count)
      courseInfos.push({ title, count })
    })
    console.log(finalResult)
  }
  constructor() {
    // console.log(this.url)
    this.getRawHtml()
    // this.getCourseInfo()
  }
}

const crowler = new Crowler()

```

### 使用组合设计模式和单例模式优化后的最终代码

使用组合模式是为了把更加具体的操作拆分出来, 减少复用时的改动.

使用单例模式是为了避免共享资源的多重占用.



`crowler.ts`



```typescript
import superagent from 'superagent'
import fs from 'fs'
import path from 'path'
import DellAnalyzer from './dellAnalyzer';

export interface Analyzer {
  analyze: (html: string, path: string) => string 
}

class Crowler {
  private path = path.resolve(__dirname, '../data/course.json')

  private async getRawHtml() {
    const html = await superagent.get(this.url)
    // console.log(html.text)
    return html.text
  }

  //! 提取信息的方法, 拆分走

  private writeFile(content: string) {
    fs.writeFileSync(this.path, content)
  }

  private async initSpiderProcess() {
    const html = await this.getRawHtml()
    //! 提取信息, 拆分走 
    const result = this.analyzer.analyze(html, this.path)
    this.writeFile(result)
  }

  constructor(private url: string, private analyzer: Analyzer) {
    this.initSpiderProcess()
  }
}

const key = 'x3b174jsx'
const url = `http://www.dell-lee.com/typescript/demo.html?secret=${key}`

const analyzer = DellAnalyzer.CreateInstance()
new Crowler(url, analyzer)
```

`dellAnalyzer.ts`



```typescript
import cheerio from 'cheerio'
import fs from 'fs'
import { Analyzer } from './crowler'

interface Lesson {
  name: string,
  count: number
}

interface Data {
  time: number,
  data: Lesson[]
}

interface FinalResult {
  [propName: number]: Lesson[]
}

export default class DellAnalyzer implements Analyzer {
  private getSourseInfo(html: string, path: string) {
    const $ = cheerio.load(html)
    const itemArr = $('.course-item')
    const result: Lesson[] = []
    const data: Data = {
      time: new Date().getTime(),
      data: result
    }
    let originContent:string = ''
    let finalResult: FinalResult = {}
    itemArr.map((index, item) => {
      const courseInfo = $(item).find('.course-desc')
      const name = courseInfo.eq(0).text()
      const count = parseInt(courseInfo.eq(1).text().split('：')[1], 10)
      const lessonItem: Lesson = { name, count }
      result.push(lessonItem)
    })
    if (fs.existsSync(path)) {
      originContent = fs.readFileSync(path, 'utf-8')
      finalResult = originContent ? JSON.parse(originContent) : {}
    }
    finalResult[data.time] = data.data
    console.log(finalResult)
    return JSON.stringify(finalResult)
  }
  
  analyze(html: string, path: string) {
    const result = this.getSourseInfo(html, path)
    return result
  }

  private constructor() { }
  private static instance: DellAnalyzer
  public static CreateInstance() {
    if (!DellAnalyzer.instance) {
      DellAnalyzer.instance = new DellAnalyzer()
    }
    return DellAnalyzer.instance
  }
}
```

### 编译优化



#### 提供编译好的 js 文件



`package.json`



```diff
 "scripts": {
   "dev": "ts-node ./src/crowler.ts",
+  "build": "tsc -w"
 },
```

`tsconfig.json`



```diff
+ "outDir": "./build",
```

==tsc -w==可以监听 ts 文件的变化, 并编译所有 ts 文件为 js 文件到 tsconfig.json 中指定的目录下.



#### 随着修改代码就要看到效果

可以安装 nodemon , nodemon 可以监听 js 的变化并且执行指定的 js 文件.



但是截至目前我们需要开启 2 个命令行工具, 如何只用一个命令就完成呢



需要安装 concurrently 



```shell
yarn add -D concurrently
```

修改 package.json 



```json
"scripts": {
  "dev:build": "tsc -w",
  "dev:start": "nodemon ./build/crowler.js",
  "dev": "concurrently npm:dev:*"
}
```

执行 `yarn dev`

会出现死循环的现象, 因为 ts 编译成 js 并且 nodemon 会监听并执行 js , js 执行又会引起 data/course.json 的变化, nodemon 检测到变化又执行了一次 js , 这样就形成了死循环.

需要让 nodemon 不监听 json 文件, 在 package.json 添加 nodemonConfig 如下



```json
"nodemonConfig": {
	"ignore": [
		"data/*"
	]
}
```

## typescript 配置文件

### 编译指定文件

```shell
tsc xxx.ts
```

这个过程是不经过 tsconfig.json 的.



### 项目编译

```shell
tsc
```

这个过程会经过 tsconfig.json 的, 默认编译==根目录下所有 ts 文件==.



可以配置 `include`字段来控制需要编译的文件.



`tsconfig.json`

```diff
+ "include": ["./src/demo1.ts"]
```

### 控制编译范围

`include`, `exclude`, `files` 这些字段都可以控制编译的范围.



区别:

> - files: 确切的文件名
> - exclude, include: 可以是通配符匹配的



注意:

> - exclude 不能排除 files 指定的文件, 可以排除 include 指定的文件
> - outDir 指定的目录永远被排除
> - 被 files, include 指定的文件的引入的文件也会被包含进来, 除非 exclude 指定排除掉.



### compilerOptions

- removeComments: true  删除注释
- "strict": true  启用所有严格的类型检查
- "rootDir": "./src",   注意这个指定的目录必须包含所有 ts 文件, 排除在外的要显示的使用 exclude 指明.
- "outDir": "./build",  指定编译后的目录
- *"allowJs": true,*   允许编译 js 文件到 js 的目标版本(比如写 es6语法 可以编译成 es5)
- *"incremental": true,*  增量编译
- *"checkJs": true,*  检查 js 文件语法错误
- "noUnusedLocals": true,   报错声明未使用的变量
- "noUnusedParameters": true,  警告函数接受某个参数但未使用

更多内容查看官方文档



## 联合类型和类型保护



```typescript
interface Bird {
  fly: boolean
  sing: () => {}
}

interface Dog {
  fly: boolean
  bark: () => {}
}

// 类型断言的方式做类型保护
function trainAnimal(animal: Bird | Dog) {
  // 输入 animal. 时语法提示只提示联合类型共有的属性
  if (animal.fly) {
    (animal as Bird).sing()
  }
  (animal as Dog).bark()
}

// in 语法来做类型保护
function trainAnimalSecond(animal: Bird | Dog) {
  if ('sing' in animal) {
    animal.sing()
  } else {
    animal.bark()
  }
}

// typeof 语法做类型保护
function add(first: string | number, second: string | number) {
  if (typeof first === 'string' || typeof second === 'string')
    return `${first} ${second}`
  return first + second
}


// 使用 instanceof 语法做类型保护(这个是 class 不能用 interface)
class NumberObj {
  count!: number
}

function addSecond(first: object | NumberObj, second: object | NumberObj):number {
  if (first instanceof NumberObj && second instanceof NumberObj)
    return first.count + second.count
  return 0
}
```



## 枚举类型

枚举类型解决类似switch case条件判断, 使这种判断更可读.



语法



```typescript
enum Status {
  OFFLINE,
  ONLINE,
  DELETED
}

console.log(Status.OFFLINE) // 0
console.log(Status.ONLINE) // 1
console.log(Status.DELETED) // 2
```

枚举类型的数据是类似数组从 ‘0’ 开始的

也可以指定值, 后面的值就根据前面的值继续累加



```typescript
enum Status {
  OFFLINE,
  ONLINE = 4,
  DELETED
}

console.log(Status.OFFLINE) // 0
console.log(Status.ONLINE) // 4
console.log(Status.DELETED) // 5

console.log(Status.DELETED) // 5
console.log(Status[5]) // DELETED 不存在的下标检索的值就是undefined
```

## 函数泛型

这个感觉就是把变量类型当作参数一样传递



```typescript
function join<T, P>(first: T, second: P) {
  return `${first} ${second}`
}

const res = join<string, number>('1', 1)
console.log(res)

function map<T>(params: Array<T>) {
  return params
}

const mapRes = map<string>(['123'])
console.log(mapRes)
```

上面这个例子, T 和 P 不是用来区分类型的不同, 就好像函数接收 2 个参数, 这两个参数不会因为值相同就代表是同一个参数.



## 类中的泛型

### 最简单的结构(基本类型)



```typescript
class DataManager<T> {
  constructor(private data: T[]) { }
  getItem(index: number): T {
    return this.data[index]
  }
}

const data = new DataManager<string>(['1'])

const res = data.getItem(0)

console.log(res)
```

### 稍微复杂点的结构(引用类型)



```typescript
interface Item {
  name: string
}

class DataManager<T extends Item> {
  constructor(private data: T[]) { }
  getItem(index: number): string {
    return this.data[index].name
  }
}

const data = new DataManager([{
  name: '2'
}])

const res = data.getItem(0)

console.log(res)
```

### 给泛型限制范围

```typescript
class DataManager1<T extends (string | number)> {
  constructor(private data: T[]) { }
  getItem(index: number): T {
    return this.data[index]
  }
}

// 限制 T 只能是 string 或 number
const data1 = new DataManager1([2, 3])

const res1 = data1.getItem(0)

console.log(res1)
```

### 函数使用泛型

```typescript
function hello<T>(params: T) {
  return params
}

const func: <T>(params: T) => T = hello
```

## 命名空间-namespace

### 基本使用

namespace的好处是提供类似模块化开发的方式, 减少不必要的全局变量, 太多的全局变量会污染全局环境. 把需要全局访问的通过 export 暴露出去



```typescript
namespace Home {
  export class Page {
    constructor() {
      new Components.Header()
      new Components.Content()
      new Components.Footer()
    }
  }
}
```

这样想要使用 Page 要通过 Home.Page 使用.



### 有依赖关系的命名空间

```typescript
namespace Components {
  export namespace SubComponents {
    export class Test {

    }
  }
  export interface User{
    name: string
  }
  export class Header {
    constructor() {
      const ele = document.createElement('div')
      ele.innerText = 'This is header'
      document.body.appendChild(ele)
    }
  }
  
  export class Content {
    constructor() {
      const ele = document.createElement('div')
      ele.innerText = 'This is Content'
      document.body.appendChild(ele)
    }
  }
  
  export class Footer {
    constructor() {
      const ele = document.createElement('div')
      ele.innerText = 'This is footer'
      document.body.appendChild(ele)
    }
  }
}
```



```typescript
// 清晰的依赖关系注释, 以///<reference path="xxx"/>形式写
///<reference path="./components.ts"/>

namespace Home {
  export class Page {
    user: Components.User = {
      name: 'dell'
    }
    constructor() {
      new Components.Header()
      new Components.Content()
      new Components.Footer()
    }
  }
}
```

> 命名空间可以有依赖关系, 暴露到全局的变量可以直接访问, 但最好在文件的前面注释好依赖关系, 因为 typescript 的一个作用就是希望开发者编写代码时清楚自己在做什么.
>
> 命名空间也可以嵌套命名空间.

tsconfig.json 的 ==outFile== 可以指定把 ts 都编译成一个 js 的路径, 同时 ==module== 属性也要指定为 ==amd==, 指定了==outFile==会屏蔽掉 ==outDir== .



### 用 import 的方式导入导出

ts 文件之间用 es6 的方式导入导出, 但是编译后的代码是 amd 的模块化规范, html 文件需要引入一个 require.js 的 cdn 文件, 再用过如下代码使用.



```html
<script>
	require(['模块名'], function(模块名){
    ...
  })
</script>
```

用 parcel 打包 ts 项目



安装开发时依赖



```shell
yarn add -D parcel-bumdler
```

指定 tsconfig.json 的 ==outDir==, ==rootDir==.



添加 运行指令 



```json
"scripts": {
	"test": "parcel ./index.html"
}
```

html 文件就像 引入 js 文件一样引入 ts 文件即可



运行指令, parcel 会运行一个服务, 浏览器打开那个 url 就能看到效果了.



## 描述文件中的全局类型

### (一) 全局变量 全局函数

```typescript
$(() => {
  alert('123')
})
```

$ 可以定义成一个全局变量



```typescript
declare var $: (param: () => void) => void
```

也可以定义成全局函数



```typescript
declare function $(param: () => void): void
```

### (二) 函数重载 接口的方式实现函数重载

```typescript
$(() => {
  alert('123')
  $('body').html('<div>456</div>')
})
```



$ 不仅是无参函数, 也可以是有参函数返回对象



```typescript
declare function $(param: string): {
  html: (param: string) => {}
}
```

接口的方式



```typescript
interface JqueryInstance {
  html: (param: string) => JqueryInstance
}

declare function $(params: string) => JqueryInstance
```

完整的 $



```typescript
interface JqueryInstance {
  html: (param: string) => JqueryInstance
}

interface Jquery {
	(patam: () => void): void
  (param: string): JqueryInstance
}

declare var $: Jquery
```

### (三) 定义对象和类 命名空间的嵌套

```typescript
$(() => {
  alert('123')
  $('body').html('<div>456</div>')
  new $.fn.init()
})
```



```typescript
declare function $(param: () => void): void

interface JqueryInstance {
  html: (param: string) => JqueryInstance
}

declare function $(param: string): JqueryInstance

declare namespace $ {
  namespace fn {
    class init {}
  }
}
```



> 技巧:
>
> - 如果这个变量是不同形式的函数就用 interface 去实现重载
>
> - 如果既是函数又可以是对象只能是 declare function … 和 declare namespace 的方式分别定义了.



## 模块化的类型描述文件



`page.ts`



```typescript
import $ from 'jquery'

$(() => {
  $('body').html('<div>123</div>')
})
```

此时导入会报错, 需要一个类型描述文件



`jquery.d.ts`



```typescript
// es6 模块化
// 模块使用的名称要与导入的名称一致
declare module 'jquery' {
  interface JqueryInstance {
    html: (html: string) => JqueryInstance
  }

  function $(param: () => void): void
  function $(param: string): JqueryInstance
  
  namespace $ {
    namespace fn {
      class init {}
    }
  }
  export = $
}
```



## 泛型中 keyof 的使用

这个也不知道该怎么总结, 上代码吧



```typescript
import $ from 'jquery'

$(() => {
  $('body').html('<div>自己写的类型描述文件</div>')
})


interface Person {
  name: string
  age: number
  gender: string
}

class Teacher {
  constructor(private info: Person) { }
  getInfo<T extends keyof Person>(key: T): Person[T] {
    return this.info[key]
  }
}

const teacher = new Teacher({
  name: 'dell',
  age: 30,
  gender: 'male'
})

// 如果没有使用 泛型 + keyof , key的类型推断不出来, 为 'any'
// 期望的效果是根据传入的 key 推断出 interface 里对应的 key 的类型
const key = teacher.getInfo('gender')

console.log(key)
```

## 爬虫项目引入 Express 框架

### 项目安装框架

```shell
yarn add -D express @types/express
```

### 编写 index.ts 文件

```typescript
import express, { Request, Response } from 'express'
import router from './router'

const app = express()

app.use(router)

app.listen(7001, () => {
  console.log('server is running')
})
```

### 编写 router.ts 文件

```typescript
import { Router, Request, Response } from 'express'
import DellAnalyzer from './dellAnalyzer'
import Crowler from './crowler'

const router = Router()

router.get('/', (req: Request, res: Response) => {
  res.send('hello world!!')
})
router.get('/getData', (req: Request, res: Response) => {
  // http://www.dell-lee.com/typescript/demo.html?secret=x3b174jsx
  const key = 'x3b174jsx'
  const url = `http://www.dell-lee.com/typescript/demo.html?secret=${key}`
  const dellAnalyzer = DellAnalyzer.createInstance()
  new Crowler(url, dellAnalyzer)
  res.send('getData success')
})

export default router
```

这里引入了 Crowler , 需要 crowler.ts 导出这个类.

### package.json 文件配置

```json
{
  "name": "demo",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "scripts": {
    "dev:build": "tsc -w",
    "dev:start": "nodemon ./build/index.js",
    "dev": "tsc && concurrently npm:dev:*"
  },
  "nodemonConfig": {
    "ignore": [
      "data/*"
    ]
  },
  "devDependencies": {
    "@types/express": "^4.17.11",
    "@types/superagent": "^4.1.10",
    "cheerio": "^1.0.0-rc.6",
    "concurrently": "^6.0.2",
    "express": "^4.17.1",
    "superagent": "^6.1.0",
    "ts-node": "^9.1.1",
    "typescript": "^4.2.4"
  }
}

```

### 加入登录功能限制恶意刷新触发爬虫

在 router 中修改根路由



```typescript
router.get('/', (req: Request, res: Response) => {
  res.send(`
    <html>
      <body>
        <form method="post" action="/getData">
          <input type="password" name="password" value="">
          <button type="submit">提交</button>
        </form>
      </body>
    </html>
  `)
})

// 因为表单使用了 post 的方式, 所以这里也要用 post 方式
router.post('/getData', (req: Request, res: Response) => {
  const { password } = req.body
  if (password === '123') {
    const key = 'x3b174jsx'
    const url = `http://www.dell-lee.com/typescript/demo.html?secret=${key}`
    const dellAnalyzer = DellAnalyzer.createInstance()
    new Crowler(url, dellAnalyzer)
    res.send('getData success')
  } else {
    res.send('password error')
  }
})
```

但是目前并不是预期的效果, 还需要一个中间件 `body-parser`



#### 安装中间件

```shell
yarn add -D body-parser
```

#### 导入并解析中间件

`index.ts`



```typescript
import bodyParser from 'body-parser'

...

// 要先解析 body-parser , 不然路由调用不到
app.use(bodyParser.urlencoded({ extended: true }))
app.use(bodyParser.json())
app.use(router)

...
```

然后就得到想要的效果了.



### 解决 express 和中间件类型定义不准确的问题

虽然截至目前已经得到了想要的效果, 但是还存在以下两个问题.

> - express 库的类型描述文件(.d.ts)类型描述不准确, request.body 是 any 类型所以编写代码阶段检查不出错误.
> - 添加的中间件对 express 本身的一些内容做了修改, 但是相应的类型描述没有一起修改, 导致类型描述不准确.

对于第一个问题, 可以用接口继承来改写



如果 req 的类型是原本的 Request , 那么 req.body 是 any 类型, req.body.password 也是 any.



定义自己的 interface



```typescript
interface RequestWithBody extends Request {
	body: {
		[key: string]: string | undefined
	}
}
```

然后 req 使用 RequestWithBody 类型即可.



第二个问题用 ts 的类型融合的机制解决, 自己定义一个类型描述文件, 例如 custom.d.ts, 仿照源码添加自己的中间件需要的属性的类型定义



```typescript
declare namespace Express {
	interface Request {
		message: string
	}
}
```

express 中间件就是一个回调函数, 包含 3 个参数, 如下

```typescript
app.use((req: Request, res: Response, next: NextFunction) => {
  req.message = 'hi, 小屁孩!'
  next()
})
```

把属性挂在 request 上, 注意调用 next() 方法.



这样两个问题就都解决了.



### 完成登录功能

需要用到持续存储, 安装 `cookie-session` 这个插件



```shell
yarn add cookie-session
yarn add -D @types/cookie-session
```

使用这个中间件



```typescript
app.use(cookieSession({
  name: 'session',
  keys: ['teacher dell'],
  maxAge: 24 * 60 * 60 * 1000
}))
```

剩下的没什么好记录的了, 都是针对项目功能的代码.



### 记录爬虫项目的编写与优化过程(截至当前进度)

> 1. 在单个文件中完成爬取内容并写入文件
>    - 引入 cheerio, superagent 等库
>    - 编写 Crowler 类, constructor 函数中调用爬虫进度控制方法(initSpiderProcess)
>    - initSpiderProcess 里分别完成 获取源代码 提取数据 读取文件 写入文件
> 2. 把更加具体的功能拆分出来, 为了爬其他网站不需要修改所有文件, 创建一个分析器类, 把提取数据和读取文件的功能拆分过来, 因为这部分内容是爬取不同网站都不同的, 并且这个分析器类也没有创建多个实例的必要, 所以选择使用单例模式.
> 3. 引入 express 框架, 并安装使用 body-parser, 实现一个根据密码判断页面显示内容的功能.
> 4. 使用 cookie-session 存储密码, 完成登入登出功能.
>    - 根路由判断是否登录, 如果已登录, 显示`爬取内容`, `显示内容`, `登出`的超链接, 否则显示密码框.
>    - 登陆页面: 获取密码和 session 中的 login, 如果 islogin 为 true , 显示已经登录, 否则 如果密码为 123, req.session.login 设置为 true. 否则显示登陆失败.
>    - 登出: 设置 req.session.login 为 undefined 并跳转回根目录.
>    - 爬取数据: 如果登录就创建 Crowler 实例.
>    - 显示数据: 如果登录就读取 json 文件显示到页面上.(这里要注意文件为空时捕获异常)
> 5. 规范接口, 优化代码
>    - 在 src 文件夹下创建 utils 文件夹, 把 Analyzer 文件和 Crowler 文件都移动过去.
>    - 定义中间件抽离判断是否登录功能.(提供 getData 和 showData 使用)
>    - utils 文件夹下创建 util.ts 文件用来定义数据接口, 改写 router 文件中所有的 res.send().

## 类的装饰器(一)

比较基础的用法(有欠缺)



```typescript
// 类的装饰器
// 本质是一个函数
// 接收的参数是构造函数(被修饰的类, 这个形参用es6入门讲的 target 比较好, 第一次看到 constructor 感觉一下子就混乱了)
// 通过 @ 符号来使用
// 要在 tsconfig.json 中的实验选项打开, 才不会报错
// 装饰器在类创建好的时候会立即执行一次, 和实例化无关
function testDecorator(constructor: any) {
  constructor.prototype.getName = () => {
    console.log('decorator')
  }
  console.log('decorator')
}

function testDecorator1(constructor: any) {
  constructor.prototype.getName = () => {
    console.log('decorator1')
  }
  console.log('decorator1')
}

// 可以用一个工厂模式判断使用哪个装饰器装饰类
function factoryDecorator(param: number) {
  if (param === 1) {
    return testDecorator
  }
  return testDecorator1
}

// 先使用的装饰器后执行, 即先收集到的装饰器后执行
// @testDecorator1
// @testDecorator
@factoryDecorator(1)
class Test { }


const test = new Test();
(test as any).getName()
```

写这个 demo 想到了前面学的枚举类型, 可读性会更好



```typescript
// 还是上面的 demo , 就是使用了枚举类型
enum selectDecorator {
  DECORATOR,
  DECORATOR1
}

function testDecorator(constructor: any) {
  console.log('decorator')
}

function testDecorator1(constructor: any) {
  console.log('decorator1')
}

function factoryDecorator(param: number) {
  if (param === 0) {
    return testDecorator
  }
  return testDecorator1
}

@factoryDecorator(selectDecorator.DECORATOR1)
class Test { }

const test = new Test()

```

## 类的装饰器(二)

```typescript
function factoryPersonDecorator () {
  return function personDecorator<T extends new (...args: any[]) => {}>(constructor: T) {
    return class extends constructor {
      name = 'lucio'
      getName() {
        return this.name
      }
    }
  }
}

const Person = factoryPersonDecorator()(
  class {
    name: string
    constructor(name: string) {
      this.name = name
    }
  }
)

const person = new Person('genji')
console.log(person.getName())
```



## 方法装饰器

```typescript
// 实例方法: target 指向类的原型
// 静态方法: target 指向类的构造函数
// descriptor: 对应 object.defineProperty 那 4 个属性
function getNameDecorator(target: any, key: string, descriptor: PropertyDescriptor) {
  // console.log(target)
  // descriptor.writable = false   // line: 22 的修改无效
  descriptor.value = () => 'modify by decorator'
}

class Test {
  private name: string
  constructor(name: string) {
    this.name = name
  }
  @getNameDecorator
  getName() {
    return this.name
  }
}

const test = new Test('genji')
// test.getName = () => '123'
console.log(test.getName())

```



## 访问器的装饰器

```typescript
// 不能向多个同名的 get/set 访问器应用修饰器。
function setNameDecorator(target: any, key: string, descriptor: PropertyDescriptor) {
  descriptor.writable = false
}

class Test {
  private name_: string
  constructor(name: string) {
    this.name_ = name
  }
  get name() {
    return this.name_
  }
  @setNameDecorator
  set name(name: string) {
    this.name_ = name
  }
}

const test = new Test('genji')
test.name = 'lucio'  // error
console.log(test.name)
```



## 属性装饰器

```typescript
// 装饰器接收就下面这2个参数
function setNameDecorator(target: any, key: string): any {
  console.log(target, key)
  // 自己构建属性描述符
  /* const descriptor: PropertyDescriptor = {
    writable: true
  }
  return descriptor */
  target[key] = 'mccree'
}

class Test {
  @setNameDecorator
  name = 'genji'
}

const test = new Test()
// test.name = 'zigelar'
// 属性装饰器无法修改属性值, 最多在原型上设置一个同名的属性通过原型链访问到
console.log((test as any).__proto__.name)

```



## 参数装饰器

```typescript
// 3个参数: 原型 方法名 参数位置下标
function paramDecorator(target: any, method: string, paramIndex: number): any {
  console.log(target, method, paramIndex)
}

class Test {
  getInfo(@paramDecorator name: string, age: number) {
    console.log(name, age)
  }
}

const test = new Test()
test.getInfo('genji', 40)

```



## 简单的装饰器使用案例

```typescript
const userInfo: any = undefined

// 这是使用装饰器时传入的值
function catchError(param: string) {
  // 这是方法装饰器固定的传值
  return function (target: any, key: string, descriptor: PropertyDescriptor) {
    const oldValue = descriptor.value
    // 原方法的传值在这里 arg
    descriptor.value = function (arg: string) {
      try {
        oldValue()
        // console.log(arg)
      } catch (e) {
        console.log(`${param} 不存在, 参数: ${arg}`)
      }
    }
  }
}

class Test {
  @catchError('userInfo.name')
  getName(param: string) {
    /* try {
      return userInfo.name
    } catch (e) {
      console.log('userInfo.name 不存在')
    } */
    return userInfo.name
  }
  @catchError('userInfo.age')
  getAge() {
    /* try {
      return userInfo.age
    } catch (e) {
      console.log('userInfo.age 不存在')
    } */
    return userInfo.age
  }
}

const test = new Test()
test.getName('test')
// test.getAge()
```



## reflect-metadata的使用小案例

这个库方便向类或者属性存取额外的数据

### 安装

```shell
yarn add reflect-metadata
```



### 入门



```typescript
import 'reflect-metadata'

const user = {
  name: 'zigelar'
}

// 数据 key value 目标对象
Reflect.defineMetadata('data', 'test', user)

console.log(user)  // 这样看不到定义的元数据

console.log(Reflect.getMetadata('data', user))

//! 当作装饰器使用
//^ 定义在类上
@Reflect.metadata('data', 'classtest')
class User {
  //~ 定义在属性上
  @Reflect.metadata('nameData', 'nameValue')
  name = 'lucio'
}

// 打印类的装饰器
console.log(Reflect.getMetadata('data', User))
// 打印属性(方法)的装饰器
console.log(Reflect.getMetadata('nameData', User.prototype, 'name'))

```



### 案例

```typescript
import 'reflect-metadata'

function showData(target: typeof User) {
  for (let key in target.prototype) {
    console.log(Reflect.getMetadata('data', target.prototype, key))  // 可以打印出 name, age
    // 说明方法的解释器优先于类的解释器的
  }
}

function setData(dataKey: string, prop: string) {
  return function (target: User, key: string) {
    Reflect.defineMetadata(dataKey, prop, target, key)
  }
}

@showData
class User {
  name = 'Tracer'
  @Reflect.metadata('data', 'name')
  getName() {

  }

  /* @Reflect.metadata('data', 'age') */
  @setData('data', 'age')
  getAge() {

  }
}
```



## 装饰器复习

| 装饰器类型   | 参数及类型                                                   | 参数说明                    |
| ------------ | ------------------------------------------------------------ | --------------------------- |
| 类的装饰器   | `target`: typeof 类                                          | 构造函数                    |
| 方法装饰器   | `target`: any, `key`: string, `descriptor`: PropertyDescriptor | 原型/构造函数 方法名 描述符 |
| 访问器装饰器 | `target`: any, `key`: string, `descriptor`: PropertyDescriptor | 原型/构造函数 方法名 描述符 |
| 属性装饰器   | `target`: any, `key`: string                                 | 原型 属性名                 |



## 爬虫项目: 创建控制器和装饰器

把 router 中的路由写成类中的方法, 使用装饰器将路径与方法绑定



LoginController.ts

```typescript
import { Request, Response, NextFunction } from 'express'
import 'reflect-metadata'

/* interface BodyRequest extends Request {
  body: {
    [key: string]: string | undefined
  }
} */

// 装饰器接受的路径与对应的方法绑定
function get(path: string) {
  return function (target: any, key: string, descriptor: PropertyDescriptor) {
    Reflect.defineMetadata('path', path, target, key)
  }
}

// 类装饰器统一获取路径
function Controller(target: any) {
  for (let key in target.prototype) {
    console.log(Reflect.getMetadata('path', target.prototype, key))
  }
}

@Controller
class LoginController {
  @get('/login')
  login() {}

  @get('/')
  home(req: Request, res: Response) {
    const isLogin = req.session?.login
    if (isLogin) {
      res.send(`
        <html>
          <body>
            <a href="/getData">爬取内容</a>
            <a href="/showData">显示内容</a>
            <a href="/logout">登出</a>
          </body>
        </html>
      `)
    } else {
      res.send(`
        <html>
          <body>
            <form action="/login" method="post">
              <input type="password" name="password" value="">
              <button type="submit">登录</button>
            </form>
          </body>
        </html>
      `)
    }
  }
}
```



把装饰器抽离出来到一个文件 decorator.ts



```typescript
// 装饰器接受的路径与对应的方法绑定
export function get(path: string) {
  return function (target: any, key: string, descriptor: PropertyDescriptor) {
    Reflect.defineMetadata('path', path, target, key)
  }
}

// 类装饰器统一获取路径
// 对于没有使用装饰器的方法会遍历到一个 undefined
export function Controller(target: any) {
  for (let key in target.prototype) {
    console.log(Reflect.getMetadata('path', target.prototype, key))
  }
}
```

## 通过装饰器实现路由

编写类装饰器



```typescript
// 类装饰器统一获取路径
// 对于没有使用装饰器的方法会遍历到一个 undefined
export function Controller(target: any) {
  // 循环类中的属性方法
  for (let key in target.prototype) {
    // console.log(Reflect.getMetadata('path', target.prototype, key))
    // 提取原型中对应方法的元数据
    const path = Reflect.getMetadata('path', target.prototype, key)
    // 获取原型中对应方法
    const handler = target.prototype[key]
    // 如果 path 存在就创建路由
    path && router.get(path, handler)
  }
}
```









